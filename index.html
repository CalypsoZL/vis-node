<!DOCTYPE html>
<html>
  <head>
    <title>Vis Node</title>
    <style type="text/css">
        body {
          margin: 0;
        }
        #container {
          position: absolute;
          width: 100%;
          height: 100%;
        }
      </style>
  </head>
  <body>
    <audio id="audio-element"
           src=""
           controls="true"
           style="width: 512px;">
    </audio>
    <p style="display: inline-block;">Pick audio file:</p>
    <input type="file" id="files" name="files[]" multiple />
    <!-- <div><canvas id="fft" width="512" height="200"></canvas></div> -->
    <!-- <svg id="wav" viewBox="0 -1 6000 2" preserveAspectRatio="none">
        <g>
            <path id="waveform" d=""/>
        </g>
    </svg> -->
    <div id="container"></div>
    <script src="./sigma.min.js"></script>
    <script src="./visnode.js"></script>
    <script src="./index.js"></script>
    <script>
        var interval = -1;
        var loading = -1;
        function handleFileSelect(evt) {
            const files = evt.target.files; // FileList object
            let i = 0;
            loading = setInterval(() => {
                nodes[i++ % nodes.length].input(5);
            }, 300);
            clearInterval(interval)
            // files is a FileList of File objects. List some properties.
            const output = [];
            for (let i = 0, f; f = files[i]; i++) {
                if (f.type !== "audio/mp3") {
                    continue;
                }
                const aud = document.getElementById("audio-element");
                aud.src = window.URL.createObjectURL(f);
                var audio = new Aud(f);
                const audioSourceNode = audio.context.createMediaElementSource(aud)
                audio._loadTrack(f).then((buffer) => {
                    const analyser = audio.context.createAnalyser();
                    audioSourceNode.connect(analyser);
                    analyser.connect(audio.context.destination);
                    analyser.fftSize = Math.pow(2, 13);
                    const bufferLength = analyser.frequencyBinCount;
                    const dataArray = new Float32Array(bufferLength);
                    new Waveform("#wav", analyser, dataArray);
                    console.log(buffer.numberOfChannels)
                })
            }
        }

        document.getElementById('files').addEventListener('change', handleFileSelect, false);

        class Aud {
            constructor(f) {
                console.log(f)
                this.context = this._createAudioContext();
                // this._loadTrack(f);
            }

            _createAudioContext() {
                if (!window.audioContextInstance) {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;

                if (window.AudioContext) {
                    window.audioContextInstance = new AudioContext();
                } else {
                    alert('Web Audio API is not supported in this browser');
                }
            }

                return window.audioContextInstance;
            }

            _loadTrack(f) {
                return f.arrayBuffer().then((buffer) => {
                    return this.context.decodeAudioData(buffer)
                })
            }
        }
        const PEAK_COUNT = 6000;
        class Waveform {
            constructor(svgPathId, analyser, dataArray) {
                this.svgPathId = svgPathId;
                this.analyser = analyser;
                this.dataArray = dataArray;
                // console.log(this._getPeaks(PEAK_COUNT))
                // this.draw();
                this.setNodes();
            }
            setNodes() {
                let i = 0;
                // const peaks = this._getPeaks(PEAK_COUNT);
                // const totalPeaks = peaks.length;
                // const size = Math.round(this.buffer.length / this.buffer.sampleRate) % Math.round(Math.sqrt(nodes.length));
                // console.log(this.buffer, size)
                const bins = this.analyser.frequencyBinCount;
                const speed = 100;
                let increment = Math.floor(bins / nodes.length);
                const run = () => {
                    s.myUpdate();
                    nodes.forEach(node => node.decay());
                    nodes.forEach(node => node.distributeCharge());
                    this.analyser.getFloatFrequencyData(this.dataArray);

                    for (let i = 0; i < min(bins, nodes.length); i++) {
                        const decibels = clamp(this.dataArray[i*increment], this.analyser.minDecibels, this.analyser.maxDecibels);
                        if (decibels > spread(0.9, this.analyser.minDecibels, this.analyser.maxDecibels)) {
                            console.log();
                        }
                        const val = Math.pow(regularize(decibels, this.analyser.minDecibels, this.analyser.maxDecibels)/(i % 15+1)*3.5, 2)
                        // const val = clamp(Math.pow(this.dataArray[i*increment]+140,3)/(500000*max(nodes[i].charge, 1)), 0,  10);
                        // if (val < 1.625) continue;
                        nodes[i].input(val/Math.pow(nodes[i].charge+1, 1.2));
                    }
                    if (increment > 1 && this.dataArray[(i-1)*increment] < 140) {
                        increment--;
                    }
                    if (increment < Math.floor(bins / nodes.length) && this.dataArray[(i)*increment] > 140) {
                        increment++;
                    }
                    s.refresh();
                };
                interval = setInterval(run, speed);

                const aud = document.getElementById("audio-element");



                // const run = () => {
                //     const a = (~~(i/2)+1)
                //     const b = (peaks.shift()+1)
                //     const j = i % size;
                //     const k = ++i % size;
                //     nodes[j].input(a/Math.pow(nodes[j].charge, nodes[j].charge));
                //     nodes[k].input(b/Math.pow(nodes[k].charge, nodes[k].charge));
                //     if (i % 2) nodes.forEach(node => node.decay());
                //     // console.log(nodes[0].charge, nodes[1].charge);
                //     if (i >= totalPeaks) clearInterval(interval);
                // };
                clearInterval(loading);
                // aud.onpause = () => {
                //     clearInterval(interval);
                // };
                // aud.onplay = () => {
                //     interval = setInterval(run, speed);
                // };
                aud.play();
            }

            // _getPeaks(length) {
            //     const sampleSize = this.buffer.length / length;
            //     const sampleStep = ~~(sampleSize / 10) || 1;
            //     const numberOfChannels = this.buffer.numberOfChannels;
            //     const mergedPeaks = [];

            //     for (let channelNumber = 0; channelNumber < numberOfChannels; channelNumber++) {
            //         const peaks = [];
            //         const channelData = this.buffer.getChannelData(channelNumber);

            //         for (let peakNumber = 0; peakNumber < length; peakNumber++) {
            //             const start = ~~(peakNumber * sampleSize);
            //             const end = ~~(start + sampleSize);
            //             let min = channelData[0];
            //             let max = channelData[0];

            //             for (let sampleIndex = start; sampleIndex < end; sampleIndex += sampleStep) {
            //                 const value = channelData[sampleIndex];

            //                 if (value > max) { max = value; }
            //                 if (value < min) { min = value; }
            //             }

            //             peaks[2 * peakNumber] = max;
            //             peaks[2 * peakNumber + 1] = min;

            //             if (channelNumber === 0 || max > mergedPeaks[2 * peakNumber]) {
            //                 mergedPeaks[2 * peakNumber] = max;
            //             }

            //             if (channelNumber === 0 || min < mergedPeaks[2 * peakNumber + 1]) {
            //                 mergedPeaks[2 * peakNumber + 1] = min;
            //             }
            //         }
            //     }
            //     return mergedPeaks;
            // }
            // draw() {
            //     console.log(this.svgPath())
            //     document.getElementById("wav").setAttribute('d', this.svgPath());
            // }

            // svgPath() {
                //     const peaks = this._getPeaks(PEAK_COUNT);
            //     const totalPeaks = peaks.length;

            //     let d = '';
            //     for(let peakNumber = 0; peakNumber < totalPeaks; peakNumber++) {
                //         if (peakNumber%2 === 0) {
            //             d += ` M${~~(peakNumber/2)}, ${peaks.shift()}`;
            //         } else {
            //             d += ` L${~~(peakNumber/2)}, ${peaks.shift()}`;
            //         }
            //     }
            //     return d;
            // }
        }
        // var audio = new Audio("file:///Users/Theo/Coding_Projects/node-vis/SoundHelix-Song-1.mp3");
        // new Waveform({svgPathId: "#wav", buffer: audio.buffer});
    </script>
  </body>
</html>
